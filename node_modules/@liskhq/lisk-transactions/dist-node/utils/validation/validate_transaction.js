'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _validator = require('./validator');

var _validator2 = _interopRequireDefault(_validator);

var _schema = require('./schema');

var schemas = _interopRequireWildcard(_schema);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright Â© 2018 Lisk Foundation
 *
 * See the LICENSE file at the top-level directory of this distribution
 * for licensing information.
 *
 * Unless otherwise agreed in a custom licensing agreement with the Lisk Foundation,
 * no part of this software, including this file, may be copied, modified,
 * propagated, or distributed except according to the terms contained in the
 * LICENSE file.
 *
 * Removal or modification of this copyright notice is prohibited.
 *
 */

var schemaMap = {
	0: _validator2.default.compile(schemas.transferTransaction),
	1: _validator2.default.compile(schemas.signatureTransaction),
	2: _validator2.default.compile(schemas.delegateTransaction),
	3: _validator2.default.compile(schemas.voteTransaction),
	4: _validator2.default.compile(schemas.multiTransaction),
	5: _validator2.default.compile(schemas.dappTransaction)
};

var getTransactionSchemaValidator = function getTransactionSchemaValidator(type) {
	var schema = schemaMap[type];
	if (!schema) {
		throw new Error('Unsupported transaction type.');
	}
	return schema;
};

var validateMultiTransaction = function validateMultiTransaction(tx) {
	if (tx.asset.multisignature.min > tx.asset.multisignature.keysgroup.length) {
		return {
			valid: false,
			errors: [{
				dataPath: '.asset.multisignature.min',
				message: '.asset.multisignature.min cannot be greater than .asset.multisignature.keysgroup.length'
			}]
		};
	}
	return {
		valid: true,
		errors: null
	};
};

var validateTransaction = function validateTransaction(tx) {
	var validateSchema = getTransactionSchemaValidator(tx.type);
	var valid = validateSchema(tx);
	// Ajv produces merge error when error happens within $merge
	var errors = validateSchema.errors ? validateSchema.errors.filter(function (e) {
		return e.keyword !== '$merge';
	}) : null;
	if (valid && tx.type === 4) {
		return validateMultiTransaction(tx);
	}
	return {
		valid: valid,
		errors: errors
	};
};

exports.default = validateTransaction;